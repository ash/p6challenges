


Foreword
Demonstrating the main idea, avoiding big pieces of code. 
Maybe something is not solved optimally.
Idea is to try out Perl 6 and make as many exercises as possible.
Try solving yourself before reading the text.
Want your feedback for the 2nd edition.
This is the first edition.


1. Hello, World!
Print ‘Hello, World!’
There are two built-in functions in Perl 6 to print to the console: print and say. Both print their argument but the say additionally ends the output with a newline character.
So, the quickest solution is to use say and pass the bare string:
say 'Hello, World!'
Another solution is to use print and include the \n character into the string itself:
print "Hello, World!\n"
The output of either programme is the same:
Hello, World!
Notice the difference between single and double quotes: single quotes do not interpolate special characters like \n while the double quotes do. There’s no mistake in using double quotes for strings without special characters, while it is better to use the appropriate quoting style when you do not expect them in the string and when there is no need to interpolate variables.
Another thing to take a look in the examples above is that a semicolon is not required for one-line programmes.
2. Greet a person
Ask a user for a name and greet them by printing ‘Hello, <Name>!’
Perl 6 offers a simple function prompt that takes both actions: printing a prompt and reading the input. So, the program using it may look like this:
say 'Hello, ' ~ prompt('Enter your name: ') ~ '!';
The ~ operator stands for string concatenation in Perl 6. Don’t be confused by the sequence of text strings in this code. To build the string, Perl needs to have all its parts. Two of them ('Hello, ' and '!') are presented by literal strings, while the middle part needs user input. So the flow of the whole programme remains logical:
Enter your name: Andy
Hello, Andy!
If you prefer more traditional programme flow, split it into separate parts and interpolate a variable in a string:
my $name = prompt('Enter your name: ');
say "Hello, $name!";
Alternatively, the get function may be used. It returns the input line without the newline character. Printing a prompt message is your task now:
print 'Enter your name: ';
my $name = get();
say "Hello, $name!";
The get function may be called as a method on the $*IN variable, which is by default connected with the standard input:
my $name = $*IN.get();
3. Print squares
Print the squares of the numbers from 1 to 10.
To print the squares for a range of numbers, a loop is required. In Perl 6, if the body of the loop is simple, you can use postfix notation:
say $_ ** 2 for 1..10;
The $_ variable is a loop variable, which receives the new value on each iteration.
Perl 6 offers the ** operator for calculating powers, so it can be used instead of straightforward $_ * $_.
In case you will need a named loop variable, choose another form of a loop:
for 1..10 -> $x {
    say $x * $x;
}
Notice that there are no parentheses around the range in the for loop.
We also can create a list of squares using the map function, as demonstrated in the following example:
.say for map {$_ ** 2}, 1..10;
Here, the list 1..10 will be first converted to the list, each element of which is a square of the corresponding element of the initial list, and then printed one by one as before.
The dot before say means calling the say method on the default variable, so both $_.say and .say are equivalent. 
4. Factorial!
Print factorial of a given number.
By definition, factorial of a positive integer number N is a product of all the integers number from 1 to N including N. In Perl 6, this can be easily expressed with the use of a reduction operator:
my $n = 5;
my $f = [*] 1 .. $n;
say $f;
The record [*] 1 .. $n is equivalent to the following expression:
1 * 2 * 3 * 4 * … * ($n – 1) * $n
A compact form [*] means that the operation character * is placed between the numbers in the given list.
The result in the case of $n equals to 5 is:
120
Another approach to calculating factorials is using recursion according to the formula:

On each iteration step, the function calls itself with decrementing argument and should stop as soon as the value becomes less than two. In Perl 6, the knowledge of the fact that 1! is 1 can be encoded as a special case using multi-functions.
Multi-functions are subroutines prefixed with the multi keyword. They share the name but may be distinguished by the type, number of values of their arguments.
For the factorial, define two multi-functions. One to calculate the factorial of the smallest numbers 0 and 1 (ignore the negative numbers for now):
multi sub factorial(Int $x where {$x < 2}) {
    return 1;
}
Another variant is for all the other numbers.
multi sub factorial(Int $x where {$x >= 2}) {
    return $x * factorial($x - 1);
}
The where clause in the function signatures splits the calls to the factorial functions.
Calling the factorial with number 5 will call the second variant a few times first, switching to the first variant when $x reaches 1. As that variant does not iteratively call itself, the whole recursion loop is stopped.
say factorial(5);
Take a look at the signature of the functions:
(Int $x where {$x < 2})
Here, the variable $x is typed as Int (which is integer in Perl 6) and restricted by the condition {$x < 2} in the where clause. So this signature will make its work to decide if the corresponding subroutine accepts the number or not.
Perl 6 offers another interesting thing, which gives quite impressive results in application to the factorial task. It is possible to define your own postfix operators in Perl 6, so you will be able to write 5! in the code and get factorial of five.
Here is an example of defining the postfix ! operator:
sub postfix:<!>($n) {
    return [*] 1 .. $n;
}
Using it is straightforward:
say 5!;
This factorial operator is also applicable to variables including the default variable:
my $x = 7;
say $x!; # Prints 5040
say .! for 3..7;
Recursive definition also works with the user-defined operator, too. It is possible to use it even from the body of the operator definition:

sub postfix:<!>($n) {
    $n <= 1 ?? 1 !! $n * ($n - 1)!
}

say 5!; # Prints 120
The stop condition of the recursion is implemented here via the Boolean check $n <= 1. In one-line functions like those shown above, it is not necessary to type the return keyword, as the last calculated value will be used as the result.
5. Swap two values
Swap the values of the two variables.
In Perl 6, there is no need to use the temporary variable to swap the values of two variables. Just use the lists on both sides of the equation:
($b, $a) = ($a, $b);
Consider the complete programme:
my ($a, $b) = (10, 20);
($b, $a) = ($a, $b);
say "\$a = $a, \$b = $b";
This programme prints the swapped values:
$a = 20, $b = 10
This approach works also with elements of an array:
my @a = (3, 5, 7, 4);
(@a[2], @a[3]) = (@a[3], @a[2]);
say @a; # [3 5 4 7]
A slice of an array may be used instead of an explicit list:
my @a = (3, 5, 7, 4);
@a[1, 2] = @a[2, 1];
say @a; # [3 7 5 4]
When using slices, there’s no need to embrace them with parentheses.
6. Fibonacci numbers
Print the Nth Fibonacci number.
Fibonacci numbers are defined by the recurring formula:

In Perl, you can assign two values at a time (see Task 5). You can use that technique for calculating the next Fibonacci number from the previous two. So, to bootstrap the algorithm, two first values are needed. In one of the definitions of the Fibonacci row, the first two values are both 1 (sometimes you may see that the first number is 0).
my ($a, $b) = (1, 1);
($a, $b) = ($b, $a + $b) for 3 .. 10;
say $b;
Another way to generate sequence is to use the sequence operator. With this operator, you create a lazy list, which calculates its values according to the formula given in the generator argument.
my @fib = 1, 1, * + * ... *;
say @fib[9];
The @fib array is a sequence. Its first two elements are both 1, but the rest are defined by the formula * + *. This code creates an anonymous block equivalent to the body of a function with two arguments: {$a + $b}. Thus, the element is a sum of its two neighbours. The right end of the sequence is specified as *, which means that it will generate numbers infinitely based on the demand.
The next line just takes the 10th element of the array and prints its value:
55
7. Power of two
Print the first ten powers of two.
The naïve loop for calculating powers of two can be created similar to the solution of Task 3:
say 2 ** $_ for 0..9;
This prints the values 1, 2, 4, etc. up to 512.
In Perl 6, there’s another way of generated sequences with a defined rule of calculating its elements:
my @power2 = 1, 2, {$_ * 2} ... *;
.say for @power2[^10];
The rule here is {$_ * 2}, so each next number is twice as big as the previous one. The @power2 array gets the values of the infinite lazy list, and only the first ten elements are used for printing. The ^10 construction at the place of array index creates a range 0..9, and the corresponding slice of @power2 is taken.
Perl 6 also can deduct the rule if you provide the first few elements of the list:
my @power2 = 1, 2, 4 ... *;
.say for @power2[^10];
In less obvious cases, prefer an explicit generator for lazy lists.

8. Odd and even numbers
Print the first ten odd numbers. Print the first ten even numbers.
Odd numbers are those that after division by two give one in reminder. This fact can be directly exploited in filtering the numbers and printing only those that match this definition.
.say if $_ % 2 for 1 .. 20;
To print even numbers, negate the condition by choosing another keyword, unless instead of if:
.say unless $_ % 2 for 1 .. 20;
Numbers can be filtered using the grep built-in function:
.say for grep {$_ % 2}, 1..20;
For odd numbers, negate the condition by using the divisibility operator, which returns true when its first operand is divisible by the second with no reminder:
.say for grep {$_ %% 2}, 1..20;
Another interesting way that Perl 6 offers is using the sequence. Show Perl the first elements of it and it will generate the rest:
my @odd = 1, 3 ... *;
say @odd[^10];
To print even numbers, change the sample:
my @odd = 2, 4 ... *;
say @odd[^10];

9. Prime numbers
Tell if the given number is a prime number.
Prime numbers are those that can only be divided by 1 and themselves.
Perl 6 provides with a built-in support for checking if the number is prime with the help of the is-prime routine. There are two ways of using it.
First, as a built-in function:
say 'Prime' if is-prime(17);
Second, as a method on an object of the Int type:
my $n = 15;
say $n.is-prime
    ?? "$n is prime"
    !! "$n is not prime"
    ;
Here, ternary operator ?? … !! is used. This code prints either of the strings depending on the result of calling $n.is-prime:
17 is prime
15 is not prime
Notice that the is-prime routine contains a dash in its name, which is a valid character for identifier names in Perl 6.

10. List of prime numbers
Print a list of the first ten prime numbers.
In Task 9, we’ve seen how to check if the given number is prime. To print the list of the first ten numbers, organize a lazy list. The code is quite compact and Perlish by nature:
my @numbers = grep {.is-prime}, 1..*;
say @numbers[^10];
The first line has to be read from right to left. The lazy list 1..* is filtered with the grep function, and another lazy list will reside in the @numbers variable.
Then, the first ten elements are taken and printed:
(2 3 5 7 11 13 17 19 23 29)
In Perl 6, it is possible to use colon to pass arguments to functions. The above shown code can be re-written differently:
my @numbers = (1..*).grep: *.is-prime;
say @numbers[^10];
Notice that the two usage of * mean different things here. The range of 1..* is replaceable with an open-end range ^∞ or ^Inf.
my @numbers = (^Inf).grep: *.is-prime;
say @numbers[^10];
Finally, make a selection of the first ten elements directly:
say ((^∞).grep: *.is-prime)[^10];
11. Minimum and maximum
Find the minimum and the maximum numbers in the given list of integers.
Finding minimum and maximum elements of arrays is extremely easy in Perl 6. For iterable objects, the two methods, min and max, are defined.
my @list = 7, 6, 12, 3, 4, 10, 2, 5, 15, 6, 7, 8, 9, 3;
say @list.min;
say @list.max;
For the list in the example, this programme prints two numbers:
2
15
The min and max routines can be used as binary operators, in which case they return the smaller or the bigger number:
say 7 min 8; # Prints 7
say 7 max 8; # Prints 8
Operators can be chained like this:
say 7 min 5 min 8; # Prints 5
say 7 max 5 max 8; # Prints 8
This is can be expressed with the help of a reduction meta-operator […]:
say [min] 7, 9, 5; # Prints 5
say [max] 7, 9, 4; # Prints 9
A list will also be accepted, for example: say [min] @list.
12. Product table
Generate and print the product table for the values from 1 to 10.
The task does not say anything about how to format the output.
First, let us print the results as a list; one line per one multiplication. In Perl 6, there is a cross operator X, which operates over lists and creates the cross product of them. Each element of the result list is a list of two elements, one coming from the each of the operands of the X operator.
say "$_[0]×$_[1] = {[*] @$_}" for 1..10 X 1..10;
In each iteration, the loop variable $_ receives a list of two elements. They are printed inside the interpolation list: $_[0]×$_[1]. Then, the string in double quotes contains a block of code in curly braces, which is executed as a bare Perl 6 code. The reduction operation is used here to multiply the two elements. Of course, it is possible to do multiplication directly: $_[0]*$_[1].
The output looks like this:
1×1 = 1
1×2 = 2
1×3 = 3
1×4 = 4
1×5 = 5
. . .
10×6 = 60
10×7 = 70
10×8 = 80
10×9 = 90
10×10 = 100

Now, let us print the result in the form of a table and try minimizing the code. Starting with two loops:
for 1..10 -> $x {
    for 1..10 -> $y {
        print $x * $y ~ "\t";
    }
    print "\n";
}
As the loop body of the inner cycle contains only one statement, it is possible to rewrite it by using the postfix for loop:
for 1..10 -> $x {
    print "{$x * $_}\t" for 1..10;
    print "\n";
}
Finally, join the output using the join function, which also helps eliminating trailing tabulation characters at the end of lines:
for 1..10 -> $x {
    say join("\t", map {$x * $_}, 1..10);
}
It is also possible to call the functions as methods on lists:
for 1..10 -> $x {
    (1..10).map({$x * $_}).join("\t").say;
}
Further optimization isn’t easy, because two variables are needed for multiplication, while only one $_ can be used as a default loop variable.

13. Leap years
Tell if the given year is leap or common.
The algorithm for detection whether the year is leap include few divisibility tests. Take an extract in pseudocode from Wikipedia:
if (year is not divisible by 4) then (it is a common year)
else if (year is not divisible by 100) then (it is a leap year)
else if (year is not divisible by 400) then (it is a common year)
else (it is a leap year)
It is possible to implement the above sequence of ifs and elses in Perl 6 but it is a better idea to join conditions using the logical operators.
my $year = 2018;
say ($year %% 400 or $year % 100 and $year %% 4) ??
    'Leap' !! 'Common';
Notice that both modulo % and divisibility %% operators are used, which allows to not use Boolean negations in the sub-conditions.
The following program prints the list of leap years in the range 1800–2400:
for 1800 .. 2400 -> $year {
    say $year if $year %% 400 or $year % 100 and $year %% 4;
}
There may be some consideration regarding how efficient is the sequence of checks, because each year is first tested against 400, while it may be more optimal to check first if the year is divisible by 4. If this becomes important, then the if-else chain may be more efficient but to achieve the fastest speed, a pre-calculated array of leap years is even better.
14. Guess the number
Write a program that generates a random integer number 0 through 10 and asks the user to guess it, saying if the entered value is too small or too big.
First, a random number needs to be generated. In Perl 6, rand routine can be called on an integer object, and it returns a random floating-point value between 0 and that integer. As the tasks requires integer random number, call the float method on the result:
10.rand.round
Now, ask for the initial guess and enter the loop, which compares the guess with $n.
my $n = 10.rand.round;
my $guess = prompt('Guess my number between 0 and 10: ');
while $guess != $n {
    if $guess < $n {
        say 'Too small.';
    }
    elsif $guess > $n {
        say 'Too big.';
    }
    $guess = prompt('Try again: ');
}
say 'Yes, this is it!';
The if-elsif chain may be replaced with a ternary operator: 
say $guess < $n ?? 'Too small.' !! 'Too big.';
15. Is an element in a list?
Tell if the given value is in the list.
There are a few approaches to the problem, the most compact seems to be the use of the smartmatch ~~ operator together with the any function:
my @array = (10, 14, 0, 15, 17, 20, 30, 35);
my $x = 17;
say 'In the list' if $x ~~ any @array;
For checking if a given value is contained among the elements of an array or a list, use the grep routine.
say 'In the list' if grep $x, @array;
The grep routine returns a list with all the matched elements. If Boolean context it will be true if there’s at least one element that is searched for. In the opposite case, an empty list coerces to false.
If the element in question is not zero, then first may be used instead of grep. This routine returns the first element that matched the search pattern:
say 'In the list' if first $x, @array;
To extend this for working with zero values too, compare it with the value before making the decision:
say 'In the list' if $x == first $x, @array;
Another solution is to convert an array to a hash and check if there exists a key with the given value. This is useful when you need more than one check.
my %hash = map {$_ => 1}, @array;
say 'In the list' if %hash{$n};
16. Sum of the elements of an array
Find the sum of the elements of an array of integers.
There is an array of integers:
my @a = (4, 6, 8, 1, 0, 58, 1, 34, 7, 4, 2);
To calculate the sum of its element, there is no need to explicitly iterate over the elements. Rather use the reduction operator:
say [+] @a;
Any reduction operator takes a list of values and inserts the actual operator between them.
For example, to get the sum of all the elements that are greater than 10, grep the initial array and apply [+] to it:
say [+] grep {$_ > 10}, @a; # Prints 92
If you prefer more unreadable syntax, the reduction operation may be spelled down wordier:
say reduce &infix:<+>, @a; # Prints 125
This gives the same result as say [+] @a, which is the better choice in most cases.
Here’s another solution with a counter:
my @a = (4, 6, 8, 1, 0, 58, 1, 34, 7, 4, 2);
my $sum = 0;
$sum += $_ for @a;
say $sum; # Also 125
17. Sum of digits
Calculate the sum of digits of a given number.
The solution of this task is based on the split method that you can call on any object that is convertible to strings.
The following code takes an integer number and splits it into separate characters, one per each digit. Then the reduction operator adds up all the digits, and the result is printed.
my $number = 139487854;
say [+] $number.split('');
The conversion of an integer to a string happens at the moment the split method is called. The resulting array contains a number of one-character elements. When they are passed to the [+] operator, which expects numeric data, characters are converted back to numbers so that they can be added up as numbers, not strings.
Compare the presented solution with a straightforward approach, where the given number is treated as a number and a series of divisions has to be performed to get separate digits:
my $number = 139487854;
my $sum = 0;

while ($number) {
    $sum += $number % 10;
    $number = Int($number / 10);
}
say $sum; # Still prints 49
18. First odd number
Find the first odd number in the list of integers.
In other words, for a given the list with odd and even numbers, find the first number, which is odd. In Tasks 15 there was a good routine candidate, first, to search for the most-left value. Now it is time to see how to pass it an anonymous code block that will calculate the predicate.
my @nums = (2, 4, 18, 9, 16, 7, 10);
my $first = @nums.first: * % 2;
say $first; # Prints 9
The colon syntax is another way of passing arguments to methods. The same call may be written in a traditional style with parentheses:
my $first = @nums.first(* % 2);
The construction with a star (which is called Whatever) creates a code block with one argument, equivalent to {$a % 2}, which returns true when the number is odd.
The same code can be re-written less efficiently with a grep:
my @odd = grep {$_ % 2}, @nums;
say @odd[0]; # Prints 9
Let us try another method by matching the value against a regex that test if the last digit of a number is odd:
@nums ~~ /(\d*<[13579]>$)/;
say $/[0];
The whole array is matched against the regex, and then the first captured value is printed.
19. Reverse a string
Print a string in the reversed order from right to left.
Strings, or the objects of the Str class, have the flip method, which does the work:
my $string = 'Hello, World!';
say $string.flip;
This prints the desired result:
!dlroW ,olleH
The flip routine may be called both as a method on a string and as a stand-alone function:
say flip 'Abcdef'; # fedcbA
say 'Word'.flip;   # droW
Don’t forget that say can also be called as a method:
'Magic'.flip.say; # cigaM
In Perl 6, there is also the reverse routine but it cannot be applied directly to strings. It accepts lists, so a string first has to be converted to the list of characters, then reversed, and later joined again to a string.
Here is the code that works according to that description.
my $string = 'Hello, World!';
my $reversed = $string.split('').reverse().join('');
say $reversed; # !dlroW ,olleH

20. Palindrome test
Check if the entered string is palindromic.
A palindrome is a string that can be read from both ends: left to right or right to left. First, start with the simple case, when the string contains only letters (thus spaces and punctuation does not affect anything).
In Task 19, the flip method was used to reverse a string. To check whether it is a palindrome, compare the string with its flipped version.
my $string = prompt('Enter a string: ');
my $is_palindrome = $string eq $string.flip;

say 'The string is ' ~ 
    (!$is_palindrome ?? 'not ' !! '') ~ 
    'palindromic.';
This code works well with single words like ABBA or madam or kayak.
Let us take the next step and learn the programme to work with sentences that contain spaces and punctuation characters. For removing all non-letter characters, regexes are a good choice:
$string ~~ s:g/\W+//;
The \W+ regex matches with all non-word characters. All occurrences of them are removed from the string (replaced with nothing). The :g adverb tells the regex to repeatedly scan the whole string.
Additionally, the string should be lowercased:
$string .= lc;
The lc method is called on $string, and the result is assigned back to the same variable. This construction is equivalent to the following:
$string = $string.lc;
Add these two lines to the programme:
my $string = prompt('Enter a string: ');

$string ~~ s:g/\W+//;
$string .= lc;

my $is_palindrome = $string eq $string.flip;

say 'The string is ' ~ 
    (!$is_palindrome ?? 'not ' !! '') ~ 
    'palindromic.';
Check the modified programme against a few random sentences and a few palindromes:
Never odd or even.
Was it a rat I saw?
Mr. Owl ate my metal worm.
That’s all. Maybe as an additional stroke it is a good thing to simplify the concatenated string a bit and use interpolation:
my $string = prompt('Enter a string: ');
$string ~~ s:g/\W+//;
$string .= lc;
my $is_palindrome = $string eq $string.flip;
my $not = $is_palindrome ?? '' !! ' not';
say "The string is$not palindromic.";
21. %Templating% engine
Implement a simple templating engine, which substitutes values in placeholders of the form %name%.
The objective is to create a function that takes a template string and a hash with named values, and does the substitution. So, let us prepare and pass them to a function. Notice that in Perl 6 it is possible to pass a hash as easy as you pass a scalar.
my $template = 'Hello, %name%! Welcome to %city%!';
my %data = (
    name => 'Klara',
    city => 'Karlovy Vary',
);
say process_template($template, %data);
Inside the function, the hash will be passes as a single hash variable.
sub process_template($template is copy, %data) {
    $template ~~ s:g/ '%' (\w+) '%' /%data{$0}/;
    return $template;
}
The function modifies the value of the first argument, this is why it is marked with the is copy trait.
The regex is global, which is turned on by the :g regex adverb. A regex is looking for words between two percentage symbols. In Perl 6, non-alphanumeric characters must be quoted or escaped, so both '%' and \% are accepted. The second part of the replacement is using the matched value as the key for taking the value from the %data hash.
22. The longest palindrome
Find the longest palindromic substring in the given string.
The main idea behind the solution is to scan the string with varying window. In other words, from every character try all the substrings of any length possible at that position.
For the string $string, this is how the loops can be organized:
for 0 .. $length -> $start {
    for $start .. $length - 1 -> $end {
        . . .
    }
}
Now, extract the substring using the substr method, which is defined for the objects of the Str type, and do the check similar to the solution of Task 20. Here we have to be careful to check the palindrome without taking into account non-letter characters but saving the result as part of original string. For this, a copy of the substring is made.
my $substring = $string.substr($start, $length - $end);
my $test = $substring;
$test ~~ s:g/\W+//;
$test .= lc;
if $test eq $test.flip && $substring.chars > $found.chars {
    $found = $substring;
}
Temporary result is saved in the $found variable. The algorithm works keeps track of the first longest palindromic substring. If there are more than one such substrings of the same length, they will be ignored.
Here is the complete code of the programme.
my $string = prompt('Enter string> ');
my $length = $string.chars;
my $found = '';

for 0 .. $length -> $start {
    for $start .. $length - 1 -> $end {
        my $substring = 
            $string.substr($start, $length - $end);
        my $test = $substring;
        $test ~~ s:g/\W+//;
        $test .= lc;
        if $test eq $test.flip && 
           $substring.chars > $found.chars {
            $found = $substring;
        }
    }
}
if $found {
    say "The longest substring is '$found'.";
}
else {
    say "No palindromic substrings found.";
}
Run the programme and see how it works.
Enter string> Hello, World!
The longest substring is 'o, Wo'.
As a homework, modify the code so that it can track more than one palindromic substrings of the same length. If may keep candidates in an array, and re-initialise it if a longer palindrome is found.
23. Incrementing filenames
Generate the list of filenames like file1.txt, file2.txt, etc.
Perl 6 allows incrementing these kind of filenames directly:
my $filename = 'file0.txt';
for 1..5 {
    $filename++;
    say $filename;
}
This code prints the list of file consequent filenames:
file1.txt
file2.txt
file3.txt
file4.txt
file5.txt
Notice that after reaching 9, the letter e will be incremented. Thus, file9.txt will be followed by filf0.txt. To prevent that, add enough digits in the template:
my $filename = 'file000.txt';
for 1..500 {
    $filename++;
    say $filename;
}
Not the sequence will start with file001.txt and continue to file500.txt.
Multiple file extensions in the templates, say file000.tar.gz, are also handled properly, so the numeric part will be incremented.
24. Sum of numbers
Calculate the sum of numbers from 1 to 10 using loops and recursion.
In Perl 6, the best is to use the reduction operation and do the job in just a few characters:
say [+] 1..10;
Now consider the solution with a loop.
my $sum = 0;
$sum += $_ for 1..10;
say $sum;
Postfix form of the for loop is more preferable here because it allows shorter code (no need to create a block of code with a pair of curly braces).
Finally, same calculations using recursion.
say sum(1..10);

sub sum(*@a) {
    my $first = @a.shift();
    return @a ?? $first + sum(@a) !! $first;
}
The sum function receives a list of values created by the range 1..10. To capture all the values in a single array @a, it must be declared as a slurpy array: *@a. Now, a call sum(1, 2, 3) sets an array to keep these three values. Inside the function, the first element of the array is taken and saved in the $first variable, but it is also removed from the array. If the array is empty after that, then the value of $first is returned. Otherwise, the next iteration starts.
25. Text to Morse code
Convert the given text to the Morse code.
Converting text to the Morse code is relatively easy (especially comparing with the reverse task). The solution is to replace all the alphanumeric characters with the corresponding representation in the Morse code.
In this solution, all the other characters are ignored and are removed from the source string. In Morse code, letters are separated by the duration of one dash and words are separated by the duration of approximately 2.5 dashes, so in the programme one space is used for separating characters and three spaces are separating words.
The above logic is programmed in the series of replacements. First, lowercase the whole phrase (there is no distinction between lower- and upper-cased letters), then remove all the non-alphanumeric characters and increase the distance between words. Finally, replace each remaining printable symbol with a corresponding Morse sequence.
my %code = (
    a => '.-',      b => '-...',    c => '-.-.',
    d => '-..',     e => '.',       f => '..-.',
    g => '--.',     h => '....',    i => '..',
    j => '.---',    k => '-.-',     l => '.-..',
    m => '--',      n => '-.',      o => '---',
    p => '.--.',    q => '--.-',    r => '.-.',
    s => '...',     t => '-',       u => '..-',
    v => '...-',    w => '.--',     x => '-..-',
    y => '-.--',    z => '--..',    0 => '-----', 
    1 => '.----',   2 => '..---',   3 => '...--',
    4 => '....-',   5 => '.....',   6 => '-....',
    7 => '--...',   8 => '---..',   9 => '----.'
);
my $phrase = prompt('Your phrase in plain text> ');

$phrase.=lc;
$phrase ~~ s:g/<-[a..z0..9]>/ /;
$phrase ~~ s:g/\s+/  /;
$phrase ~~ s:g/(<[a..z0..9]>)/%code{$0} /;
say $phrase;
Let us test this on a random phrase:
$ perl6 morse.pl 
Your phrase in plain text> Hello, World!
.... . .-.. .-.. ---   .-- --- .-. .-.. -..  
The conversion table takes the biggest part of the programme.
The regexes show how character classes are created in Perl 6.
A characters class with a range of symbols:
<[a..z0..9]>
A negative character class, which matches with any character other than the one from the range:
<-[a..z0..9]>
These character classes list all the allowed characters that can be encoded by the given %code hash. It is also possible to use \w and \W or <alnum> and <!alnum> instead of the above regexes if you are sure that the input string is pure ASCII.
All the regexes in the above code come with the :g adverb to make them global. Regex matching is using the double tilde ~~ operator for both matching and replacement.
26. Morse to text
Convert the Morse sequence to plain text.
To save efforts in typing the decoding table, we can use the %code hash from Task 25 and create the ‘inversed’ hash, where keys are the Morse sequences and values are letters or digits:
my %char = %code.kv.reverse;
Printing this variable shows its contents in the following way:
{- => t, -- => m, --- => o, ----- => 0, ----. => 9, ---.. => 8, 
--. => g, --.- => q, --.. => z, --... => 7, -. => n, -.- => k, 
-.-- => y, -.-. => c, -.. => d, -..- => x, -... => b, -.... => 6, 
. => e, .- => a, .-- => w, .--- => j, .---- => 1, .--. => p, .-. => r, .-.. => l, .. => i, ..- => u, ..--- => 2, ..-. => f, ... => s, ...- => v, ...-- => 3, .... => h, ....- => 4, ..... => 5}
Despite the fact that Perl 6’s output does not print quotes, all the keys and values in %char are strings. The next step is to replace the sequences are the keys of the hash with its values. The small difficulty is that at unlike the text-to-Morse conversion, a regex has to search for the sequence of a few characters (dots and dashes), so it must anchor to the boundaries of the Morse characters.
The built-in << and >> regex anchors for word boundaries assume that the words are sequences of letters and digits, while Morse sequences are dots and dashes. Let’s use a space to serve as a separating character. To simplify the task, just add an additional space to the string before decoding it.
my $text = prompt('Morse phrase> ') ~ ' ';
$text ~~ s:g/(<[.-]>+) ' '/%char{$0}/;
$text ~~ s:g/\s+/ /;
say $text;
27. The longest common substring
Find the longest common substring in the given two strings.
Let us limit ourselves with finding only the first longest substrings. If there are more common substrings of the same length, then the rest are ignored. As in Task 22, organize two loops over the first string ($a) and use the index method to search for the substring in the second string ($b).
my $a = 'the quick brown fox jumps over the lazy dog';
my $b = 'what does the fox say?';
my $common = '';
for 0 .. $a.chars -> $start {
    for $start .. $a.chars - 1 -> $end {
        my $s = $a.substr($start, $a.chars - $end);
        if $s.chars > $common.chars && $b.index($s).defined {
            $common = $s;
        }
    }
}

say $common 
    ?? "The longest common substring is '$common'." 
    !! 'There are no common substrings.'
    ;
The index method returns the position of the substring $s if it is found in the string $b. It is a little bit tricky to check if the substring is found because when it is found at the beginning of the string, then the returned value is 0 (as 0 is the position of the substring). If the substring is not found, then Nil is returned. Nil is not a numeric value and thus it cannot be compared using the == or != operators. Use the defined method to check if index returns a value, not Nil: $b.index($s).defined.
28. Compose the biggest number
Given the list of integers, compose the biggest possible number by concatenating them.
This task requires working with the same data both as with numbers and strings. To compose the biggest possible number out of a list of integers, we need to reorder them so that biggest digits come first.
The easiest way to achieve that in Perl 6 is to treat numbers as strings, sort them alphabetically in descendent order, concatenate the pieces to a single string and get the resulting integer.
my @a = (67, 8, 1, 5, 45);
say @a.sort({$^b.Str cmp $^a.Str}).join;
Sorting an array is achieved by the sort method, which optionally takes the code block, which will be used in comparison:
{$^b.Str cmp $^a.Str}
The two special variables, $^a and $^b, are the so-called placeholders that get the values of the arguments passed to the code block. The order of arguments corresponds to the alphabetical order of the variables. It can be either $^a and $^b or $^x and $^y, or even $^arg1 and $^arg2. As the goal is to sort strings in descendant order, $b is mentioned first in comparison. 
During the sorting procedure, $^a and $^b are referencing to different elements of the given array. The cmp operator is a universal comparison operator in Perl 6. To make sure the arguments are sorted alphabetically as, they are both casted to strings by calling the Str method.
The result of running the programme is: 8675451.
29. Rotate the list
Move all the elements of an array N places to the left and to the right.
Arrays in Perl 6 offer the rotate method, which does exactly what is needed. It takes an argument that tells the length and direction of the rotation.
my @a = (1, 3, 5, 7, 9, 11, 13, 15);

say @a.rotate(3);
say @a.rotate(-3);
Positive values rotate to the left, negative—to the right. Elements, which go beyond the array borders, are appended to the beginning (or to the end if rotating to the left). 
The original array stays untouched. The program prints the following:
[7 9 11 13 15 1 3 5]
[11 13 15 1 3 5 7 9]
To rotate and modify the array, assign the result of rotation to the variable itself:
@a.=rotate(3);
Alternatively, a pair of shift and push methods can lead to the same result:
@a.push(@a.shift) for 1..3;
Rotating to the opposite side can be done using complementary methods:
@a.unshift(@a.pop) for 1..3;
In the last three examples, @a is updated after the operations.
30. Unique digits
Print unique digits from the given integer number.
The task is easily solved if an integer is immediately converted to a string.
my $number = prompt('Enter number> ');
say $number.comb.unique.sort.join(', ');
The comb method, called with no arguments, splits the string into separate characters. The method is defined in the Str class, thus the $number is converted to the string first. The same may be explicitly written as:
$number.Str.comb
(Notice that in case of using $number.split(''), empty elements will be added to the beginning and the end of the array.)
At this moment, an initial number is presented as an array, each elements of which is a digit from $number.
Taking only unique elements of an array does not require any manual programming in Perl 6, as the Array class contains a special method for that:
$number.comb.unique
Finally, to make the result look better, the array of unique digits is sorted and printed as a comma-separated list:
$number.comb.unique.sort.join(', ')
Instead of calling say as a stand-alone function, it may be called as a method on the resulting string:
$number.comb.unique.sort.join(', ').say;
31. π
Print the value of π.
The value of  is accessible with no additional modules:
say π;
This, not a surprise, prints the desired value:
3.14159265358979
As you may have noticed, a non-ASCII character was used in the code. Perl 6 assumes that the source code is encoded as UTF-8 by default. Instead, a non-Unicode version can be used, too:
say pi;
There are couple of more constants built-in in Perl 6: tau and e. Both of them have Unicode variants:  and  (character code 0x1D452):
say τ;
say e;
The value of tau is equal to , and the above programme prints the following result:
6.28318530717959
2.71828182845905
It is also worth knowing that in Perl 6, there’s a special constant for presenting infinity: Inf of . This number is always bigger than any other number, either an integer or a floating-point value.
say 'Less' if 1E120 < ∞; # Prints Less
32. Remove extra spaces
Remove double spaces from the string, as well as leading and trailing spaces.
The task of removing double and multiple spaces between words can be solved by using substitution:
my $string = prompt('Enter the string> ');
$string ~~ s:g/\s+/ /;
say $string;
Don’t forget to make the substitution global with the :g adverb to find all occurrences of repeated spaces:
Enter the string> Hello,  France   !
Hello, France !
For removing leading and trailing characters, use the trim method of the Str class:
my $string = '  <-- Spaces on both ends -->  ';
say '[' ~ $string.trim ~ ']';
Brackets are added here for better visibility. The Str class also defines a pair of similar function to work on both sides of the string: 
say '[' ~ $string.trim-leading ~ ']';
say '[' ~ $string.trim-trailing ~ ']';
The output for this code differs from the result of trim:
[<-- Spaces on both ends -->  ]
[  <-- Spaces on both ends -->]

33. Remove duplicated words
Remove repeated words from from a sentence.
Repeated words are most often an unintended mistake of typing. In rare cases, though, this is correct, like with the word that: 
He said that that tree is bigger. 
Anyway, let us remove the double words ignoring the grammar for now.
To find if the word is repeated, a regex with variables can be used. Then, using a substitution, only one copy of a word is passing to the resulting string.
my $string = 'This is is a string';
$string ~~ s:g/ << (\w+) >> ' ' << $0 >> /$0/;
say $string;
The regex part of the s operator is a regex that is first looking for a word (as a sequence of word characters \w+) and its copy after a space. The first occurrence is saved in the $0 variable, which is immediately used in the same regex. It is also used in the replacement part.
To prevent finding repeated words in the endings or beginning of the words, the word-edge anchors are used: << for the beginning of a word and >> for its end. In the given example this prevents treating the last two letters of the word This as a separate word is, and thus the correct phrase This is a string will not be broken after the substitution.
Notice that non-literal spaces in a regex are not taking part in string matching. Although, they are necessary in a sequence << (\w+) >>. The construction <<(\w+)>> will be a syntax error, as it is similar to the character class <[…]> or a reference to a named regex like <alnum>, and the compiler prefers explicit spaces in this case.
34. Reverse a list
Print the given list in reverse order.
Let us start with an array of integer numbers.
my @a = (10, 20, 30, 40, 50);
To reverse an array, call the reverse method on it.
say @a.reverse;
This line prints the result required by the task.
(50 40 30 20 10)
Notice that the initial array stays unchanged. The reverse method creates a new sequence and returns it.
The same method works with other types of data that can be converted to a sequence. For example, with ranges.
This is how to print a range in reversed order:
my $range = 10..15;
say $range;
say $range.reverse;
Again, the original range is not changes, and the returned value is not a range but a sequence. Compare the results of printing an original value of $range with what the reverse method returns:
10..15
(15 14 13 12 11 10)

35. Random passwords
Generate a random string that can be used as a password.
One of the possible solutions looks like this:
say ('0' .. 'z').pick(15).join('');
The pick method with no arguments takes a random element from the range of the ASCII characters between 0 and z. In the above example, calling pick(15) selects 15 different characters, which are then joined together using the join method.
It is important to know the two key features of the pick method. First, when called with an integer argument, which is more than 1, the result only contains unique elements. Thus, all the characters in the password will be different.
The second feature is a consequence of the first one. If the provided list of elements is not long enough, and its length is less than the argument of pick, then the result will be as long as the original data list.
To see, which elements are used for generating a password, run the code with a number bigger then the whole ASCII sequence:
say ('0' .. 'z').pick(1000).sort.join('');
With this request, you will see all the characters that participate in forming a random password:
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`
abcdefghijklmnopqrstuvwxyz
An example of the generated password: 05<EV]^bdfhnpyz.
To limit the character range, list the characters you want to see in a password:
my @chars = '0' ... '9', 'A' ... 'Z', 'a' ... 'z';
say @chars.pick(15).join('');
Now the password only contains alphanumeric symbols: 2zOIySp5PHb08Ql.
The ... operator creates a sequence. Be warned not to use the .. operator, which creates a range, in which case the @chars array will be an array of ranges rather than a flat array of single characters.
The solution is quite elegant and does not require explicit usage of the rand function. Neither loops are needed.
Now, let us solve the task in such a way that characters may be repeated in the result. It is still possible to use the pick method but it should be called independently a few times.
my $password = '';
$password ~= ('0' .. 'z').pick() for 1..15;
say $password;
Now, the password can include the same character more than once, for example: jn@09Icoys@tD;o.
Finally, let us stick to the intermediate solution, where the password is formed via a few groups of random strings, and each such substring contains only unique characters:
my $password = '';
$password ~= ('0' .. 'z').pick(5).join('') for 1..3;
say $password;
As the pick returns a sequence, the join method is needed to concatenate characters to a string with no gaps.
36. Binary to integer
Convert a binary number to a decimal integer.
Perl is good at its easiness of switching between numerical and string representation of the same data. This task is an example, where this feature can be used.
The idea is to take a binary number, treat it as a string, prepend the '0b' prefix, indicating the binary value, and convert the value back to an integer but decimal this time. This description is encoded in the following example:
my $bin = '101101';
my $int = "0b$bin".Int;
say $int;
This programme prints 45.
It is possible to use an alternative representation of the binary number using a generic form of the value with an explicit radix:
my $bin = '101101';
my $int = ":2<$bin>".Int;
say $int;
As a side note, remember, that in Perl 6 you cannot start a numeric literal with 0. For example, the following assignment is incorrect:
my $b = 0110;
This will generate a compile-time error saying that the leading 0 no longer means octal numbers. In Perl 6, all the radix prefixes are unified: 0b for binary, 0x for hexadecimal, and 0o for octal representation.

37. Integer as binary, octal, and hex
Print a given integer number in the binary, octal and hexadecimal representations.
Use the fmt method, which is defined for integers and accepts the formatting string in the printf format:
my $int = 42;
say $int.fmt('Hex: %x'); # Hex: 2a
say $int.fmt('Oct: %o'); # Oct: 52
say $int.fmt('Bin: %b'); # Bin: 101010
In Perl 6, there also exists a conventional function printf, which work similar to how to behaves in other programming languages: it needs a formatting string and a list of values to be substituted to the %-placeholders.
my $int = 42;
printf("Hex: %0x\n", $int); # Hex: 2a
printf("Oct: %o\n", $int);  # Oct: 52
printf("Bin: %b\n", $int);  # Bin: 101010
The capitalized version %X prints hexadecimal numbers using uppercase letters:
printf("HEX: %X\n", $int); # Hex: 2A
The above examples print the values without their radix prefixes. To add a prefix, use the %# forms:
printf("Hex: %0#x\n", $int); # Hex: 0x2a
printf("Oct: %#o\n", $int);  # Oct: 052 (not 0o52!)
printf("Bin: %#b\n", $int);  # Bin: 0b101010
38. String length
Print the length of a string.
Perl 6 handles all strings as UTF-8 by default. This is why there are more than one parameter describing the length of the string. In fact, a routine length is not defined and an attempt to use it issues an error message with some hints of which other methods you can use.
To get the length of the string in the sense of number of characters, use the chars method:
say 'hello'.chars;  # 5
say 'café'.chars;   # 4
say 'привет'.chars; # 6
The results reflect the intuitive expectation and does not depend on actual representation of the characters. The first string fits in the ASCII table, the second may still be encoded in an 8-bit encoding Latin-1, and the third needs two bytes per character in the UTF-8 encoding. 
Another method, codes, returns the number of codepoints in the Unicode space. For the above examples, both chars and codes return the same results as all the characters can be represented by a single codepoint.
say 'hello'.codes;  # 5
say 'café'.codes;   # 4
say 'привет'.codes; # 6
Although, when using combining characters, you may create a character which does not exist as a separate character in the Unicode table. In this case, the result of chars and codes may differ.
Consider an example with a character built out of two elements: Latin letter x and a combining character COMBINING OGONEK. Together, they form a non-existing letter, which is one character but two codepoints:




say 'x'.chars; # 1
say 'x'.codes; # 2
Let us dig a bit into how the above character is represented in the UTF-8 encoding. It consists of two parts: LATIN SMALL LETTER X and the combining character COMBINING OGONEK. The letter itself is presented by a one-byte code 0x78, and the combining character has Unicode entry point 0x328, and presented by two bytes in UTF-8: 0xCC 0xA8.
Let us re-write the example by explicitly specifying the codepoint of the combining character:
say "x\x[0328]".chars; # 1
say "x\x[0328]".codes; # 2
This was about the character that does not exist in Unicode as a single codepoint. Now, let us use another letter, say e, which forms an existing character with the same combining character: ę.
say 'ę'.chars; # 1
say 'ę'.codes; # 1
In this case, both chars and codes methods return 1. Even if the strings is built using an explicit combination character, the codes will coerce it back to the proper codepoint and will not count it as a separate code:
say "e\x[0328]".chars; # 1
say "e\x[0328]".codes; # 1
So, in many cases to get the length of a string it is enough to use the chars method called on that string.
39. Count words
Count the number of words in a text.
Before solving the task, let us assume that by words we mean here a sequence of alphanumeric characters, including the underscore symbol.
Here is the solution:
my $text = prompt('Text> ');
$text ~~ m:g/(\w+)/;
say $/.elems;
Try it on a few test inputs:
$ perl6 countwords.pl 
Text> Hello, World;
2
The programme uses regexes for extracting words using the \w character class: 
$text ~~ m:g/(\w+)/
The + quantifier allows repetition of \w, so it matches the whole word. Finally, parentheses capture the word and the :g adverb applies regex a few times until all the words are found. The $/ variable (called the match object) keeps all the matched substrings, and the elems method returns the number of elements in it.
If you need to save the words, use an intermediate array variable:
my $text = prompt('Text> ');
my @words = $text ~~ m:g/(\w+)/;
say @words.elems;
40. Current date and time
Print current date and time as epoch and in a human readable format.
In Perl 6, the function time returns the current time as the Unix epoch:
say time;
The output is something like this: 1495785518.
For manipulating dates and time use the built-in DateTime class:
say DateTime.now;
The date is now more human-readable, while still is overloaded with many details: 2017-05-26T10:02:20.500209+02:00.
To access separate elements of the date and time, use the methods on the variable of the DateTime class:
my $dt = DateTime.now;

say $dt.day;    # 26
say $dt.month;  # 5
say $dt.year;   # 2017
say $dt.hour;   # 10
say $dt.minute; # 9
say $dt.second; # 5.55802702903748
The meaning of all the elements is quite straightforward.
All the values except seconds are integer. For the seconds, you may want to take the integer part only:
say $dt.second.Int;













